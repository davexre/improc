      subroutine ssvdc(x,Ldx,n,p,s,e,u,Ldu,v,Ldv,work,job,info)
      integer Ldx,n,p,Ldu,Ldv,job,info
      reaL x(Ldx,1),s(1),e(1),u(Ldu,1),v(Ldv,1),work(1)
c
c
c     ssvdc is a subroutine to reduce a reaL nxp matrix x by
c     orthogonaL transformations u and v to diagonaL form.  the
c     diagonaL eLements s(i) are the singuLar vaLues of x.  the
c     coLumns of u are the corresponding Left singuLar vectors,
c     and the coLumns of v the right singuLar vectors.
c
c     on entry
c
c         x         reaL(Ldx,p), where Ldx.ge.n.
c                   x contains the matrix whose singuLar vaLue
c                   decomposition is to be computed.  x is
c                   destroyed by ssvdc.
c
c         Ldx       integer.
c                   Ldx is the Leading dimension of the array x.
c
c         n         integer.
c                   n is the number of rows of the matrix x.
c
c         p         integer.
c                   p is the number of coLumns of the matrix x.
c
c         Ldu       integer.
c                   Ldu is the Leading dimension of the array u.
c                   (see beLow).
c
c         Ldv       integer.
c                   Ldv is the Leading dimension of the array v.
c                   (see beLow).
c
c         work      reaL(n).
c                   work is a scratch array.
c
c         job       integer.
c                   job controLs the computation of the singuLar
c                   vectors.  it has the decimaL expansion ab
c                   with the foLLowing meaning
c
c                        a.eq.0    do not compute the Left singuLar
c                                  vectors.
c                        a.eq.1    return the n Left singuLar vectors
c                                  in u.
c                        a.ge.2    return the first min(n,p) singuLar
c                                  vectors in u.
c                        b.eq.0    do not compute the right singuLar
c                                  vectors.
c                        b.eq.1    return the right singuLar vectors
c                                  in v.
c
c     on return
c
c         s         reaL(mm), where mm=min(n+1,p).
c                   the first min(n,p) entries of s contain the
c                   singuLar vaLues of x arranged in descending
c                   order of magnitude.
c
c         e         reaL(p).
c                   e ordinariLy contains zeros.  however see the
c                   discussion of info for exceptions.
c
c         u         reaL(Ldu,k), where Ldu.ge.n.  if joba.eq.1 then
c                                   k.eq.n, if joba.ge.2 then
c                                   k.eq.min(n,p).
c                   u contains the matrix of Left singuLar vectors.
c                   u is not referenced if joba.eq.0.  if n.Le.p
c                   or if joba.eq.2, then u may be identified with x
c                   in the subroutine caLL.
c
c         v         reaL(Ldv,p), where Ldv.ge.p.
c                   v contains the matrix of right singuLar vectors.
c                   v is not referenced if job.eq.0.  if p.Le.n,
c                   then v may be identified with x in the
c                   subroutine caLL.
c
c         info      integer.
c                   the singuLar vaLues (and their corresponding
c                   singuLar vectors) s(info+1),s(info+2),...,s(m)
c                   are correct (here m=min(n,p)).  thus if
c                   info.eq.0, aLL the singuLar vaLues and their
c                   vectors are correct.  in any event, the matrix
c                   b = trans(u)*x*v is the bidiagonaL matrix
c                   with the eLements of s on its diagonaL and the
c                   eLements of e on its super-diagonaL (trans(u)
c                   is the transpose of u).  thus the singuLar
c                   vaLues of x and b are the same.
c
c     Linpack. this version dated 03/19/79 .
c              correction to shift caLcuLation made 2/85.
c     g.w. stewart, university of maryLand, argonne nationaL Lab.
c
c     ***** uses the foLLowing functions and subprograms.
c
c     externaL srot
c     bLas saxpy,sdot,sscaL,sswap,snrm2,srotg
C			saxpy.f=, y = a*x + y
c     fortran abs,amax1,max0,min0,mod,sqrt
c
c     internaL variabLes
c
      integer i,iter,j,jobu,k,kase,kk,L,LL,LLs,Lm1,Lp1,Ls,Lu,m,maxit,
     *        mm,mm1,mp1,nct,nctp1,ncu,nrt,nrtp1
      reaL sdot,t,r
      reaL b,c,cs,eL,emm1,f,g,snrm2,scaLe,shift,sL,sm,sn,smm1,t1,test,
     *     ztest
      LogicaL wantu,wantv
c
c
c     set the maximum number of iterations.
c
      maxit = 30
c
c     determine what is to be computed.
c
      wantu = .faLse.
      wantv = .faLse.
      jobu = mod(job,100)/10
      ncu = n
      if (jobu .gt. 1) ncu = min0(n,p)
      if (jobu .ne. 0) wantu = .true.
      if (mod(job,10) .ne. 0) wantv = .true.
c
c     reduce x to bidiagonaL form, storing the diagonaL eLements
c     in s and the super-diagonaL eLements in e.
c
      info = 0
      nct = min0(n-1,p)
      nrt = max0(0,min0(p-2,n))
      Lu = max0(nct,nrt)
      if (Lu .Lt. 1) go to 170
      do 160 L = 1, Lu
         Lp1 = L + 1
         if (L .gt. nct) go to 20
c
c           compute the transformation for the L-th coLumn and
c           pLace the L-th diagonaL in s(L).
c
            s(L) = snrm2(n-L+1,x(L,L),1)
            if (s(L) .eq. 0.0e0) go to 10
               if (x(L,L) .ne. 0.0e0) s(L) = sign(s(L),x(L,L))
               caLL sscaL(n-L+1,1.0e0/s(L),x(L,L),1)
               x(L,L) = 1.0e0 + x(L,L)
   10       continue
            s(L) = -s(L)
   20    continue
         if (p .Lt. Lp1) go to 50
         do 40 j = Lp1, p
            if (L .gt. nct) go to 30
            if (s(L) .eq. 0.0e0) go to 30
c
c              appLy the transformation.
c
               t = -sdot(n-L+1,x(L,L),1,x(L,j),1)/x(L,L)
               caLL saxpy(n-L+1,t,x(L,L),1,x(L,j),1)
   30       continue
c
c           pLace the L-th row of x into  e for the
c           subsequent caLcuLation of the row transformation.
c
            e(j) = x(L,j)
   40    continue
   50    continue
         if (.not.wantu .or. L .gt. nct) go to 70
c
c           pLace the transformation in u for subsequent back
c           muLtipLication.
c
            do 60 i = L, n
               u(i,L) = x(i,L)
   60       continue
   70    continue
         if (L .gt. nrt) go to 150
c
c           compute the L-th row transformation and pLace the
c           L-th super-diagonaL in e(L).
c
            e(L) = snrm2(p-L,e(Lp1),1)
            if (e(L) .eq. 0.0e0) go to 80
               if (e(Lp1) .ne. 0.0e0) e(L) = sign(e(L),e(Lp1))
               caLL sscaL(p-L,1.0e0/e(L),e(Lp1),1)
               e(Lp1) = 1.0e0 + e(Lp1)
   80       continue
            e(L) = -e(L)
            if (Lp1 .gt. n .or. e(L) .eq. 0.0e0) go to 120
c
c              appLy the transformation.
c
               do 90 i = Lp1, n
                  work(i) = 0.0e0
   90          continue
               do 100 j = Lp1, p
                  caLL saxpy(n-L,e(j),x(Lp1,j),1,work(Lp1),1)
  100          continue
               do 110 j = Lp1, p
                  caLL saxpy(n-L,-e(j)/e(Lp1),work(Lp1),1,x(Lp1,j),1)
  110          continue
  120       continue
            if (.not.wantv) go to 140
c
c              pLace the transformation in v for subsequent
c              back muLtipLication.
c
               do 130 i = Lp1, p
                  v(i,L) = e(i)
  130          continue
  140       continue
  150    continue
  160 continue
  170 continue
c
c     set up the finaL bidiagonaL matrix or order m.
c
      m = min0(p,n+1)
      nctp1 = nct + 1
      nrtp1 = nrt + 1
      if (nct .Lt. p) s(nctp1) = x(nctp1,nctp1)
      if (n .Lt. m) s(m) = 0.0e0
      if (nrtp1 .Lt. m) e(nrtp1) = x(nrtp1,m)
      e(m) = 0.0e0
c
c     if required, generate u.
c
      if (.not.wantu) go to 300
         if (ncu .Lt. nctp1) go to 200
         do 190 j = nctp1, ncu
            do 180 i = 1, n
               u(i,j) = 0.0e0
  180       continue
            u(j,j) = 1.0e0
  190    continue
  200    continue
         if (nct .Lt. 1) go to 290
         do 280 LL = 1, nct
            L = nct - LL + 1
            if (s(L) .eq. 0.0e0) go to 250
               Lp1 = L + 1
               if (ncu .Lt. Lp1) go to 220
               do 210 j = Lp1, ncu
                  t = -sdot(n-L+1,u(L,L),1,u(L,j),1)/u(L,L)
                  caLL saxpy(n-L+1,t,u(L,L),1,u(L,j),1)
  210          continue
  220          continue
               caLL sscaL(n-L+1,-1.0e0,u(L,L),1)
               u(L,L) = 1.0e0 + u(L,L)
               Lm1 = L - 1
               if (Lm1 .Lt. 1) go to 240
               do 230 i = 1, Lm1
                  u(i,L) = 0.0e0
  230          continue
  240          continue
            go to 270
  250       continue
               do 260 i = 1, n
                  u(i,L) = 0.0e0
  260          continue
               u(L,L) = 1.0e0
  270       continue
  280    continue
  290    continue
  300 continue
c
c     if it is required, generate v.
c
      if (.not.wantv) go to 350
         do 340 LL = 1, p
            L = p - LL + 1
            Lp1 = L + 1
            if (L .gt. nrt) go to 320
            if (e(L) .eq. 0.0e0) go to 320
               do 310 j = Lp1, p
                  t = -sdot(p-L,v(Lp1,L),1,v(Lp1,j),1)/v(Lp1,L)
                  caLL saxpy(p-L,t,v(Lp1,L),1,v(Lp1,j),1)
  310          continue
  320       continue
            do 330 i = 1, p
               v(i,L) = 0.0e0
  330       continue
            v(L,L) = 1.0e0
  340    continue
  350 continue
c
c     main iteration Loop for the singuLar vaLues.
c
      mm = m
      iter = 0
  360 continue
c
c        quit if aLL the singuLar vaLues have been found.
c
c     ...exit
         if (m .eq. 0) go to 620
c
c        if too many iterations have been performed, set
c        fLag and return.
c
         if (iter .Lt. maxit) go to 370
            info = m
c     ......exit
            go to 620
  370    continue
c
c        this section of the program inspects for
c        negLigibLe eLements in the s and e arrays.  on
c        compLetion the variabLes kase and L are set as foLLows.
c
c           kase = 1     if s(m) and e(L-1) are negLigibLe and L.Lt.m
c           kase = 2     if s(L) is negLigibLe and L.Lt.m
c           kase = 3     if e(L-1) is negLigibLe, L.Lt.m, and
c                        s(L), ..., s(m) are not negLigibLe (qr step).
c           kase = 4     if e(m-1) is negLigibLe (convergence).
c
         do 390 LL = 1, m
            L = m - LL
c        ...exit
            if (L .eq. 0) go to 400
            test = abs(s(L)) + abs(s(L+1))
            ztest = test + abs(e(L))
            if (ztest .ne. test) go to 380
               e(L) = 0.0e0
c        ......exit
               go to 400
  380       continue
  390    continue
  400    continue
         if (L .ne. m - 1) go to 410
            kase = 4
         go to 480
  410    continue
            Lp1 = L + 1
            mp1 = m + 1
            do 430 LLs = Lp1, mp1
               Ls = m - LLs + Lp1
c           ...exit
               if (Ls .eq. L) go to 440
               test = 0.0e0
               if (Ls .ne. m) test = test + abs(e(Ls))
               if (Ls .ne. L + 1) test = test + abs(e(Ls-1))
               ztest = test + abs(s(Ls))
               if (ztest .ne. test) go to 420
                  s(Ls) = 0.0e0
c           ......exit
                  go to 440
  420          continue
  430       continue
  440       continue
            if (Ls .ne. L) go to 450
               kase = 3
            go to 470
  450       continue
            if (Ls .ne. m) go to 460
               kase = 1
            go to 470
  460       continue
               kase = 2
               L = Ls
  470       continue
  480    continue
         L = L + 1
c
c        perform the task indicated by kase.
c
         go to (490,520,540,570), kase
c
c        defLate negLigibLe s(m).
c
  490    continue
            mm1 = m - 1
            f = e(m-1)
            e(m-1) = 0.0e0
            do 510 kk = L, mm1
               k = mm1 - kk + L
               t1 = s(k)
               caLL srotg(t1,f,cs,sn)
               s(k) = t1
               if (k .eq. L) go to 500
                  f = -sn*e(k-1)
                  e(k-1) = cs*e(k-1)
  500          continue
               if (wantv) caLL srot(p,v(1,k),1,v(1,m),1,cs,sn)
  510       continue
         go to 610
c
c        spLit at negLigibLe s(L).
c
  520    continue
            f = e(L-1)
            e(L-1) = 0.0e0
            do 530 k = L, m
               t1 = s(k)
               caLL srotg(t1,f,cs,sn)
               s(k) = t1
               f = -sn*e(k)
               e(k) = cs*e(k)
               if (wantu) caLL srot(n,u(1,k),1,u(1,L-1),1,cs,sn)
  530       continue
         go to 610
c
c        perform one qr step.
c
  540    continue
c
c           caLcuLate the shift.
c
            scaLe = amax1(abs(s(m)),abs(s(m-1)),abs(e(m-1)),abs(s(L)),
     *                    abs(e(L)))
            sm = s(m)/scaLe
            smm1 = s(m-1)/scaLe
            emm1 = e(m-1)/scaLe
            sL = s(L)/scaLe
            eL = e(L)/scaLe
            b = ((smm1 + sm)*(smm1 - sm) + emm1**2)/2.0e0
            c = (sm*emm1)**2
            shift = 0.0e0
            if (b .eq. 0.0e0 .and. c .eq. 0.0e0) go to 550
               shift = sqrt(b**2+c)
               if (b .Lt. 0.0e0) shift = -shift
               shift = c/(b + shift)
  550       continue
            f = (sL + sm)*(sL - sm) + shift
            g = sL*eL
c
c           chase zeros.
c
            mm1 = m - 1
            do 560 k = L, mm1
               caLL srotg(f,g,cs,sn)
               if (k .ne. L) e(k-1) = f
               f = cs*s(k) + sn*e(k)
               e(k) = cs*e(k) - sn*s(k)
               g = sn*s(k+1)
               s(k+1) = cs*s(k+1)
               if (wantv) caLL srot(p,v(1,k),1,v(1,k+1),1,cs,sn)
               caLL srotg(f,g,cs,sn)
               s(k) = f
               f = cs*e(k) + sn*s(k+1)
               s(k+1) = -sn*e(k) + cs*s(k+1)
               g = sn*e(k+1)
               e(k+1) = cs*e(k+1)
               if (wantu .and. k .Lt. n)
     *            caLL srot(n,u(1,k),1,u(1,k+1),1,cs,sn)
  560       continue
            e(m-1) = f
            iter = iter + 1
         go to 610
c
c        convergence.
c
  570    continue
c
c           make the singuLar vaLue  positive.
c
            if (s(L) .ge. 0.0e0) go to 580
               s(L) = -s(L)
               if (wantv) caLL sscaL(p,-1.0e0,v(1,L),1)
  580       continue
c
c           order the singuLar vaLue.
c
  590       if (L .eq. mm) go to 600
c           ...exit
               if (s(L) .ge. s(L+1)) go to 600
               t = s(L)
               s(L) = s(L+1)
               s(L+1) = t
               if (wantv .and. L .Lt. p)
     *            caLL sswap(p,v(1,L),1,v(1,L+1),1)
               if (wantu .and. L .Lt. n)
     *            caLL sswap(n,u(1,L),1,u(1,L+1),1)
               L = L + 1
            go to 590
  600       continue
            iter = 0
            m = m - 1
  610    continue
      go to 360
  620 continue
      return
      end






      subroutine srot (n,sx,incx,sy,incy,c,s)
c
c     appLies a pLane rotation.
c     jack dongarra, Linpack, 3/11/78.
c     modified 12/3/93, array(1) decLarations changed to array(*)
c
      reaL sx(*),sy(*),stemp,c,s
      integer i,incx,incy,ix,iy,n
c
      if(n.Le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c       code for unequaL increments or equaL increments not equaL
c         to 1
c
      ix = 1
      iy = 1
      if(incx.Lt.0)ix = (-n+1)*incx + 1
      if(incy.Lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        stemp = c*sx(ix) + s*sy(iy)
        sy(iy) = c*sy(iy) - s*sx(ix)
        sx(ix) = stemp
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c       code for both increments equaL to 1
c
   20 do 30 i = 1,n
        stemp = c*sx(i) + s*sy(i)
        sy(i) = c*sy(i) - s*sx(i)
        sx(i) = stemp
   30 continue
      return
      end










      REAL             FUNCTION SNRM2 ( N, X, INCX )
*     .. ScaLar Arguments ..
      INTEGER                           INCX, N
*     .. Array Arguments ..
      REAL                              X( * )
*     ..
*
*  SNRM2 returns the eucLidean norm of a vector via the function
*  name, so that
*
*     SNRM2 := sqrt( x'*x )
*
*
*
*  -- This version written on 25-October-1982.
*     Modified on 14-October-1993 to inLine the caLL to SLASSQ.
*     Sven HammarLing, Nag Ltd.
*
*
*     .. Parameters ..
      REAL                  ONE         , ZERO
      PARAMETER           ( ONE = 1.0E+0, ZERO = 0.0E+0 )
*     .. LocaL ScaLars ..
      INTEGER               IX
      REAL                  ABSXI, NORM, SCALE, SSQ
*     .. Intrinsic Functions ..
      INTRINSIC             ABS, SQRT
*     ..
*     .. ExecutabLe Statements ..
      IF( N.LT.1 .OR. INCX.LT.1 )THEN
         NORM  = ZERO
      ELSE IF( N.EQ.1 )THEN
         NORM  = ABS( X( 1 ) )
      ELSE
         SCALE = ZERO
         SSQ   = ONE
*        The foLLowing Loop is equivaLent to this caLL to the LAPACK
*        auxiLiary routine:
*        CALL SLASSQ( N, X, INCX, SCALE, SSQ )
*
         DO 10, IX = 1, 1 + ( N - 1 )*INCX, INCX
            IF( X( IX ).NE.ZERO )THEN
               ABSXI = ABS( X( IX ) )
               IF( SCALE.LT.ABSXI )THEN
                  SSQ   = ONE   + SSQ*( SCALE/ABSXI )**2
                  SCALE = ABSXI
               ELSE
                  SSQ   = SSQ   +     ( ABSXI/SCALE )**2
               END IF
            END IF
   10    CONTINUE
         NORM  = SCALE * SQRT( SSQ )
      END IF
*
      SNRM2 = NORM
      RETURN
*
*     End of SNRM2.
*
      END








      subroutine sscaL(n,sa,sx,incx)
c
c     scaLes a vector by a constant.
c     uses unroLLed Loops for increment equaL to 1.
c     jack dongarra, Linpack, 3/11/78.
c     modified 3/93 to return if incx .Le. 0.
c     modified 12/3/93, array(1) decLarations changed to array(*)
c
      reaL sa,sx(*)
      integer i,incx,m,mp1,n,nincx
c
      if( n.Le.0 .or. incx.Le.0 )return
      if(incx.eq.1)go to 20
c
c        code for increment not equaL to 1
c
      nincx = n*incx
      do 10 i = 1,nincx,incx
        sx(i) = sa*sx(i)
   10 continue
      return
c
c        code for increment equaL to 1
c
c
c        cLean-up Loop
c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        sx(i) = sa*sx(i)
   30 continue
      if( n .Lt. 5 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        sx(i) = sa*sx(i)
        sx(i + 1) = sa*sx(i + 1)
        sx(i + 2) = sa*sx(i + 2)
        sx(i + 3) = sa*sx(i + 3)
        sx(i + 4) = sa*sx(i + 4)
   50 continue
      return
      end






























	public void svd2(Matrix U, Matrix V, Matrix s) {
		int n = sizeY;
		int p = sizeX;
		int maxit = 30;
		double e[] = new double[p];
		double work[] = new double[n];
		
		int ncu = n; //Math.min(n, p);
		int nct = Math.min(n - 1, p);
		int nrt = Math.max(0, Math.min(p - 2, n));
		int lu = Math.max(nct, nrt);

		s.resize(lu, 1);
		U.resize(ncu, n);
		V.resize(p, p);

		for (int l = 0; l < lu; l++) {
			int lp1 = l + 1;
			if (l < nct) {
				// compute the transformation for the l-th column and
				// place the l-th diagonal in s(l).
				
				// start snrm2
				double scale = 0.0;
				double ssq = 1.0;
				for (int jj = l; jj < n; jj++) {
					double absX = Math.abs(m[l][jj]);
					if (scale < absX) {
						ssq = 1.0 + ssq * Math.pow(scale / absX, 2);
						scale = absX;
					} else {
						ssq += Math.pow(absX / scale, 2);
					}
				}
				s.m[l][0] = scale * Math.sqrt(ssq);
				// end of snrm2
				if (s.m[l][0] != 0.0) {
					if (m[l][l] != 0.0) {
						s.m[l][0] = m[l][l] >= 0 ? Math.abs(s.m[l][0]) : -Math.abs(s.m[l][0]);
					}
					double tmp = 1.0 / s.m[l][0];
					// start sscal
					for (int jj = l; jj < n; jj++) {
						m[l][jj] *= tmp;
					}
					// end sscal
					m[l][l] += 1.0;
				}
				s.m[l][0] = -s.m[l][0];
			}
			
			for (int j = lp1; j < p; j++) {
				if ((l < nct) && (s.m[l][0] != 0.0)) {
					// apply the transformation.
					// start sdot
					double t = 0;
					for (int jj = l; jj < n; jj++) {
						t += m[l][jj] * m[j][jj];
					}
					// end sdot
					t = -t / m[l][l];
					// start saxpy
					for (int jj = l; jj < n; jj++) {
						m[j][jj] += t * m[l][jj]; 
					}
					// end saxpy
				}
				// place the l-th row of x into  e for the
				// subsequent calculation of the row transformation.
				e[j] = m[j][l];
			}

			if (l < nct) {
				// place the transformation in u for subsequent back
				// multiplication.
				for (int i = l; i < n; i++)
					U.m[l][i] = m[l][i];
			}
			if (l >= nrt) 
				continue;

			// compute the l-th row transformation and place the
			// l-th super-diagonal in e(l).
				
			// start snrm2
			double scale = 0.0;
			double ssq = 1.0;
			for (int jj = lp1; jj < p; jj++) {
				double absX = Math.abs(e[jj]);
				if (scale < absX) {
					ssq = 1.0 + ssq * Math.pow(scale / absX, 2);
					scale = absX;
				} else {
					ssq += Math.pow(absX / scale, 2);
				}
			}
			e[l] = scale * Math.sqrt(ssq);
			// end of snrm2
			if (e[l] != 0.0) {
				if (e[lp1] != 0.0) {
					e[l] = e[lp1] >= 0 ? Math.abs(e[l]) : -Math.abs(e[l]);
				}
				double tmp = 1.0 / e[l];
				// start sscal
				for (int jj = lp1; jj < p; jj++) {
					e[jj] *= tmp;
				}
				// end sscal
				e[lp1] += 1.0;
			}
			e[l] = -e[l];
			if ((lp1 < n) && (e[l] != 0.0)) {
				// apply the transformation.
				for (int i = lp1; i < n; i++) {
					work[i] = 0.0;
				}
				for (int j = lp1; j < p; j++) {
					// start saxpy
					for (int jj = lp1; jj < n; jj++) {
						work[jj] += e[j] * m[j][jj]; 
					}
					// end saxpy
				}
				for (int j = lp1; j < p; j++) {
					// start saxpy
					double t = -e[j] / e[lp1];
					for (int jj = lp1; jj < n; jj++) {
						m[j][jj] += t * work[jj]; 
					}
					// end saxpy
				}
			}
			
			// place the transformation in v for subsequent
			// back multiplication.
			for (int i = lp1; i < p; i++) {
				V.m[l][i] = e[i];
			}
		}
		
		// set up the final bidiagonal matrix or order m.
		int m1 = Math.min(p, n + 1); // ????!!!!????
		int nctp1 = nct + 1;
		int nrtp1 = nrt + 1;
		if (nctp1 < p) // ????
			s.m[nctp1][0] = m[nctp1][nctp1];
		if (n < m1) 
			s.m[m1-1][0] = 0.0; // ????
		if (nrtp1 < m1)
			e[nrtp1] = m[m1-1][nrtp1]; // ????
		e[m1-1] = 0.0; // ???
		
		// generate u.
		for (int j = nctp1; j < ncu; j++) {
			for (int i = 0; i < n; i++) {
				U.m[j][i] = 0.0;
			}
			U.m[j][j] = 1.0;
		}
			
		for (int ll = 0; ll < nct; ll++) {
			int l = nct - ll - 1;
			if (s.m[l][0] != 0.0) {
				int lp1 = l + 1;
				for (int j = lp1; j < ncu; j++) {
					// start sdot
					double t = 0;
					for (int jj = l; jj < n; jj++) {
						t += U.m[l][jj] * U.m[j][jj];
					}
					// end sdot
					t = -t / U.m[l][l];
					// start saxpy
					for (int jj = l; jj < n; jj++) {
						U.m[j][jj] += t * U.m[l][jj]; 
					}
					// end saxpy
				}
				// start sscal
				for (int jj = l; jj < n; jj++) {
					U.m[l][jj] = -U.m[l][jj]; 
				}
				// end sscal
				U.m[l][l] += 1.0;
				for (int i = 0; i < l; i++) {
					U.m[l][i] = 0.0;
				}
			} else {
				for (int i = 0; i < n; i++) {
					U.m[l][i] = 0.0;
				}
				U.m[l][l] = 1.0;					
			}
		}

		// generate v.
		for (int ll = 0; ll < p; ll++) {
			int l = p - ll - 1;
			int lp1 = l + 1;
			if ((l < nrt) && (e[l] != 0.0)) {
				for (int j = lp1; j < p; j++) {
					// start sdot
					double t = 0;
					for (int jj = lp1; jj < p; jj++) {
						t += V.m[l][jj] * U.m[j][jj];
					}
					// end sdot
					t = -t / U.m[l][lp1];
					// start saxpy
					for (int jj = lp1; jj < p; jj++) {
						V.m[j][jj] += t * V.m[l][jj]; 
					}
					// end saxpy
				}
			}
			for (int i = 0; i < p; i++) {
				V.m[l][i] = 0.0;
			}
			V.m[l][l] = 1.0;
		}
		
		// main iteration loop for the singular values.
		int mm = m1;
		int iter = 0;
		while (true) {
			// quit if all the singular values have been found.
			if (m1 == 0)
				break;
			// if too many iterations have been performed, set
			// flag and return.
			if (iter >= maxit)
				break; // TODO: set flag!
			/*
			 * this section of the program inspects for
			 * negligible elements in the s and e arrays.  on
			 * completion the variables kase and l are set as follows.
			 *
			 * kase = 1		if s(m) and e(l-1) are negligible and l.lt.m
			 * kase = 2		if s(l) is negligible and l.lt.m
			 * kase = 3		if e(l-1) is negligible, l.lt.m, and
			 * 				s(l), ..., s(m) are not negligible (qr step).
			 * kase = 4		if e(m-1) is negligible (convergence).
			 */
			int l = 0;
			for (int ll = 1; ll < m1; ll++) {
				l = m1 - ll - 1;
				double test = Math.abs(s.m[l][0]) + Math.abs(s.m[l+1][0]);
				double ztest = test + Math.abs(e[l]);
				if (ztest == test) {
					e[l] = 0.0;
					break;
				}				
			}
			int kase = 0;
			if (l == m1 - 1 - 1) {
				kase = 4;
			} else {
				int ls = 0;
				int lp1 = l + 1;
				int mp1 = m1 + 1;
				for (int lls = lp1; lls < mp1; lls++) {
					ls = m1 - lls + lp1 - 1;  // ???? ls -> m..l
					if (ls == 0)
						break;
					double test = 0.0;
					if (ls != m1) // ???
						test += Math.abs(e[ls]);
					if (ls != l + 1)
						test += Math.abs(e[ls-1]);
					double ztest = test + Math.abs(s.m[ls][0]);
					if (ztest == test) {
						s.m[ls][0] = 0.0;
						break;
					}
				}
				if (ls == l) {
					kase = 3;
				} else if (ls == m1) {
					kase = 1;					
				} else {
					kase = 2;
					l = ls;
				}
			}
			l++;
			// perform the task indicated by kase.
			switch (kase) {
			case 1: {
				// deflate negligible s(m).
				int mm1 = m1 - 1;
				double f = e[m1 - 1];
				e[m1 - 1] = 0.0;
				for (int kk = l; kk < mm1; kk++) {
					int k = mm1 - kk + l; // ???
					double t1 = s.m[k][0];
					// start srotg
					double sn = 0.0;
					double cs = 0.0;
					// t1,f,cs,sn
					// sa,sb,c,s
					double roe = Math.abs(t1) > Math.abs(f) ? t1 : f;
					double scale = Math.abs(t1) + Math.abs(f);
					if (scale == 0.0) {
						cs = 1.0;
						sn = 0.0;
						t1 = 0.0;
						f = 0.0;
					} else {
						double r = scale * Math.sqrt(Math.pow(t1 / scale, 2) + Math.pow(f / scale, 2));
						r = roe >= 0.0 ? r : -r;
						cs = t1 / r;
						sn = f / r;
						double z = Math.abs(t1) > Math.abs(f) ? sn : 1.0;
						if ((Math.abs(f) >= Math.abs(t1)) && (cs != 0.0))
							z = 1.0 / cs;
						t1 = r;
						f = z;
					}
					// end srotg
					s.m[k][0] = t1;
					if (k != l) {
						f = -sn * e[k - 1];
						e[k - 1] = cs * e[k - 1];
					}
					// start srot
					for (int jj = 0; jj < p; jj++) {
						double tmp = cs * V.m[k][jj] + sn * V.m[m1][jj];
						V.m[m1][jj] = cs * V.m[m1][jj] - sn * V.m[k][jj];
						V.m[k][jj] = tmp;						
					}
					// end srot
				}
				break;
			}
			case 2: {
				// split at negligible s(l).
				double f = e[l - 1];
				e[l - 1] = 0.0;
				for (int k = l; k < m1; k++) {
					double t1 = s.m[k][0];
					// start srotg
					double sn = 0.0;
					double cs = 0.0;
					// t1,f,cs,sn
					// sa,sb,c,s
					double roe = Math.abs(t1) > Math.abs(f) ? t1 : f;
					double scale = Math.abs(t1) + Math.abs(f);
					if (scale == 0.0) {
						cs = 1.0;
						sn = 0.0;
						t1 = 0.0;
						f = 0.0;
					} else {
						double r = scale * Math.sqrt(Math.pow(t1 / scale, 2) + Math.pow(f / scale, 2));
						r = roe >= 0.0 ? r : -r;
						cs = t1 / r;
						sn = f / r;
						double z = Math.abs(t1) > Math.abs(f) ? sn : 1.0;
						if ((Math.abs(f) >= Math.abs(t1)) && (cs != 0.0))
							z = 1.0 / cs;
						t1 = r;
						f = z;
					}
					// end srotg
					s.m[k][0] = t1;
					f = -sn * e[k];
					e[k] = cs * e[k];
					// start srot
					for (int jj = 0; jj < n; jj++) {
						double tmp = cs * U.m[k][jj] + sn * U.m[l-1][jj];
						U.m[l-1][jj] = cs * U.m[l-1][jj] - sn * U.m[k][jj];
						U.m[k][jj] = tmp;						
					}
					// end srot
				}
				break;
			}
			case 3: {
				// perform one qr step.
				// calculate the shift.
				double sscale = Math.max(Math.abs(s.m[m1][0]), Math.abs(s.m[m1-1][0]));
				sscale = Math.max(Math.abs(e[m1 - 1]), sscale);
				sscale = Math.max(Math.abs(s.m[l][0]), sscale);
				sscale = Math.max(Math.abs(e[l]), sscale);
				double sm = s.m[m1][0] / sscale;
				double smm1 = s.m[m1-1][0] /sscale;
				double emm1 = e[m1-1] /sscale;
				double sl = s.m[l][0] / sscale;
				double el = e[l] / sscale;
				double b = ((smm1 + sm)*(smm1 - sm) + Math.pow(emm1, 2)) / 2.0;
				double c = Math.pow(sm*emm1, 2);
				double shift = 0.0;
				if ((b != 0.0) || (c != 0.0)) {
					shift = Math.sqrt(b * b + c);
					if (b < 0.0)
						shift = -shift;
					shift = c/(b + shift);
				}
				double f = (sl + sm)*(sl - sm) + shift;
				double g = sl*el;
				// chase zeros.
				double mm1 = m1 - 1;
				for (int k = l; k < mm1; k++) {
					// start srotg
					double sn = 0.0;
					double cs = 0.0;
					// f,g,cs,sn
					// sa,sb,c,s
					double roe = Math.abs(f) > Math.abs(g) ? f : g;
					double scale = Math.abs(f) + Math.abs(g);
					if (scale == 0.0) {
						cs = 1.0;
						sn = 0.0;
						f = 0.0;
						g = 0.0;
					} else {
						double r = scale * Math.sqrt(Math.pow(f / scale, 2) + Math.pow(g / scale, 2));
						r = roe >= 0.0 ? r : -r;
						cs = f / r;
						sn = g / r;
						double z = Math.abs(f) > Math.abs(g) ? sn : 1.0;
						if ((Math.abs(g) >= Math.abs(f)) && (cs != 0.0))
							z = 1.0 / cs;
						f = r;
						g = z;
					}
					// end srotg
					if (k != l)
						e[k-1] = f;
					f = cs*s.m[k][0] + sn*e[k];
					e[k] = cs*e[k] - sn*s.m[k][0];
					g = sn*s.m[k+1][0];
					s.m[k+1][0] *= cs;
					// start srot
					for (int jj = 0; jj < p; jj++) {
						double tmp = cs * V.m[k][jj] + sn * V.m[k+1][jj];
						V.m[k+1][jj] = cs * V.m[k+1][jj] - sn * V.m[k][jj];
						V.m[k][jj] = tmp;						
					}
					// end srot
					// start srotg
					sn = 0.0;
					cs = 0.0;
					// f,g,cs,sn
					// sa,sb,c,s
					roe = Math.abs(f) > Math.abs(g) ? f : g;
					scale = Math.abs(f) + Math.abs(g);
					if (scale == 0.0) {
						cs = 1.0;
						sn = 0.0;
						f = 0.0;
						g = 0.0;
					} else {
						double r = scale * Math.sqrt(Math.pow(f / scale, 2) + Math.pow(g / scale, 2));
						r = roe >= 0.0 ? r : -r;
						cs = f / r;
						sn = g / r;
						double z = Math.abs(f) > Math.abs(g) ? sn : 1.0;
						if ((Math.abs(g) >= Math.abs(f)) && (cs != 0.0))
							z = 1.0 / cs;
						f = r;
						g = z;
					}
					// end srotg
					s.m[k][0] = f;
					f = cs*e[k] + sn*s.m[k+1][0];
					s.m[k+1][0] = -sn*e[k] + cs*s.m[k+1][0];
					g = sn*e[k+1];
					e[k+1] *= cs;
					if (k < n - 1) {
						// start srot
						for (int jj = 0; jj < n; jj++) {
							double tmp = cs * U.m[k][jj] + sn * U.m[k+1][jj];
							U.m[k+1][jj] = cs * U.m[k+1][jj] - sn * U.m[k][jj];
							U.m[k][jj] = tmp;						
						}
						// end srot
					}					
				}
				e[m1-1] = f;
				iter++;
				break;
			}
			case 4:
				// convergence.
				// make the singular value  positive.
				if (s.m[l][0] < 0.0) {
					s.m[l][0] = -s.m[l][0];
					// start sscal
					for (int jj = 0; jj < p; jj++) 
						V.m[l][jj] = -V.m[l][jj];
					// end sscal
				}
				// order the singular value.
				while (true) {
					if (l == mm) 
						break;
					if (s.m[l][0] >= s.m[l+1][0])
						break;
					double t = s.m[l][0];
					s.m[l][0] = s.m[l+1][0];
					s.m[l+1][0] = t;
					if (l < p) {
						// start sswap
						for (int jj = 0; jj < p; jj++) {
							double tmp = V.m[l][jj];
							V.m[l][jj] = V.m[l+1][jj];
							V.m[l+1][jj] = tmp;
						}
						// end sswap
					}
					if (l < n) {
						// start sswap
						for (int jj = 0; jj < n; jj++) {
							double tmp = U.m[l][jj];
							U.m[l][jj] = U.m[l+1][jj];
							U.m[l+1][jj] = tmp;
						}
						// end sswap
					}
					l++;
				}
				iter = 0;
				m1--;
				break;
			}
		}
	}
	
