Bash manual
===========
http://www.gnu.org/software/bash/manual/bashref.html

Bash libraries
==============
https://dberkholz.com/2011/04/07/bash-shell-scripting-libraries/
https://code.google.com/archive/p/bsfl/

Braces vs parenthesis
=====================
#!/bin/bash
pushd . > /dev/null
pwd
( cd / ; pwd ; )
pwd
{ cd / ; pwd ; }
pwd
popd  > /dev/null

Variables
=========
* Define a constant
declare -r TRUE=0

* Local variable
local myvar=some value

* default values
PARAM1_IP=${1:-'172.0.0.1'}

* script home
SCRIPT_HOME=$(dirname $(readlink -f "${0}"))
or
SCRIPT_HOME=$(dirname "$(realpath -m "${0}")")
or better
SCRIPT_HOME=$(realpath -m "${0}")
SCRIPT_HOME=$(dirname "${SCRIPT_HOME}");


Abort script if any command returns non 0 exit code, i.e. "Abort on error" (exit code $? > 0)
=============================================================================================
#!/bin/bash
function finally() {
	echo "On Finally"
}

trap 'finally' EXIT
# NOTE: In trap ALWAYS use SINGLE QUOTES, not DOUBLE QUOTES, i.e.
# do use
# trap 'some command ${LINENO}'
# do not use
# trap "some command ${LINENO}"
trap 'echo "Error in ${BASH_SOURCE}:${LINENO}. Exit code is $? running \"${BASH_COMMAND}\""' ERR

echo "Enter"
false
echo "After false 1"

set -e

echo "Before false 2"
false
echo "This will not execute"


More advanced useage of trap and error handling
===============================================
function onBashErrorHandler() {
	case "${BASH_ERROR_LEVEL}" in
		0 | IGNORE | NONE)
			;;
		1 | WARN)
			echo "Warning in ${1}:${2}. Exit code is ${3} running ${4}"
			;;
		2 | EXIT)
			echo "Error in ${1}:${2}. Exit code is ${3} running ${4}"
			exit 1
			;;
	esac
}
BASH_ERROR_LEVEL=IGNORE
set -E	# This is needed to have the same trap in sub-shells and shell function
set -u	# This is to treap unset parameters/variables as errors
trap 'onBashErrorHandler "${BASH_SOURCE}" "${LINENO}" "$?" "${BASH_COMMAND}"' ERR

BASH_ERROR_LEVEL=IGNORE
false # ignored
BASH_ERROR_LEVEL=WARN
false # warning
BASH_ERROR_LEVEL=2
false # error and exit 1
echo "This one will not execute"

Make installation shell script with attached archive at the end
===============================================================
1) install-template.sh
#!/bin/bash
function findToken() {
	grep -an "^${1}\$" "$0" | head -n 1 | cut -d ':' -f 1
}
FILE=$0
OUTPUT_DIR=target_folder
OFFSET=$(($(findToken "___END_OF_SCRIPT___$") + 1))
rm -fr "$OUTPUT_DIR" && mkdir -p "$OUTPUT_DIR" && (tail -n +$OFFSET "$FILE" | tar xz -C "$OUTPUT_DIR" --)
# ... do some other stuff ...

2) Prepare the installation script
#!/bin/bash
FOU=install.sh
cp install-template.sh "$FOU"
echo >> "$FOU"
echo 'exit 0' >> "$FOU"          # This exit is to prevent the bash interpeter go into the binary archive
echo >> "$FOU"
echo '___END_OF_SCRIPT___' >> "$FOU"
tar cz [list_of_file_that_will_be_part_of_archive] >> "$FOU"
chmod +x "$FOU"

Script with configuration section(s) at the end
===============================================
function findToken() {
	grep -anm 1 "^${1}\$" "$0" | cut -d ':' -f 1
}
function extractData() {
	local end=${2:+$(($2-$1-1))}
	tail -n +$(($1+1)) "$0" | head -n ${end:-"-0"} | grep -Ev '^\s*(#.*)?$'
}
DATA_OFFSET_1=$(findToken "___SCRIPT_DATA_SECTION_1___")
DATA_OFFSET_2=$(findToken "___SCRIPT_DATA_SECTION_2___")
DATA1=$(extractData $DATA_OFFSET_1 $DATA_OFFSET_2)
echo "$DATA1"
DATA2=$(extractData $DATA_OFFSET_2)
### Now process the data in section 2
IFS=$'\n'
count=1
for i in $DATA2 ; do 
	IFS=$' \t\n'
	echo Line $count
	count=$(($count+1))
	for j in $i ; do
		echo '>> ' $j
	done
done

exit 0

___SCRIPT_DATA_SECTION_1___
   

asd
	# qwe This is comment line
zxc
	

___SCRIPT_DATA_SECTION_2___
zzz		1	a
aaa		2	b
# aaa # This is comment line
xxx		4  	d


Script with configuration section "in the middle" and variable substitution
===========================================================================
#!/bin/bash
MY_VAR='This will be replaced "inside" the configuration!'
MY_DATA=$(cat << EOF
This is some free text inside a script that can seemlessly handle
variable substituion. Example: The following line
>> \${MY_VAR} <<
is replaced in by bash and becomes:
>> ${MY_VAR} <<
This might be quite usefull.
EOF
)
echo "$MY_DATA"
