Bash manual
===========
http://www.gnu.org/software/bash/manual/bashref.html

Bash libraries
==============
https://dberkholz.com/2011/04/07/bash-shell-scripting-libraries/
https://code.google.com/archive/p/bsfl/

Usefull environment variables
=============================
$XDG_RUNTIME_DIR	-> Points to a folder mounted in the RAM and accessible only by the current user.
$-					-> Currently set flags in bash, see set --help
$DISPLAY
$LINES				-> Number of lines in current terminal

Temporary files
===============
* Create a unique folder "in-memory"
ram_dir=$(mktemp -du -p "${XDG_RUNTIME_DIR}")
function onExit {
	rm -rf "$ram_dir"
}
trap onExit EXIT

* Using a "Named pipe"
mkfifo my_pipe
echo -e "Line 1\nLine2\nLine3" > my_pipe &
cat my_pipe
rm my_pipe

* Using redirection
echo -e "Hellow\nWorld\n!" | grep -n "World"
  could be written also as:
grep -n "World" <( echo -e "Hellow\nWorld\n!" )

https://unix.stackexchange.com/questions/63923/pseudo-files-for-temporary-data

Braces vs parenthesis
=====================
#!/bin/bash
pushd . > /dev/null
pwd
( cd / ; pwd ; )
pwd
{ cd / ; pwd ; }
pwd
popd  > /dev/null

Variables
=========
* Define a constant
declare -r TRUE=0

* Local variable
local myvar=some value

* default values
PARAM1_IP=${1:-'172.0.0.1'}

* script home
SCRIPT_HOME=$(dirname $(readlink -f "${0}"))
or
SCRIPT_HOME=$(dirname "$(realpath -m "${0}")")
or better
SCRIPT_HOME=$(realpath -m "${0}")
SCRIPT_HOME=$(dirname "${SCRIPT_HOME}");

Abort script if any command returns non 0 exit code, i.e. "Abort on error" (exit code $? > 0)
=============================================================================================
#!/bin/bash
function finally() {
	echo "On Finally"
}

trap 'finally' EXIT
# NOTE: In trap ALWAYS use SINGLE QUOTES, not DOUBLE QUOTES, i.e.
# do use
# trap 'some command ${LINENO}'
# do not use
# trap "some command ${LINENO}"
trap 'echo "Error in ${BASH_SOURCE}:${LINENO}. Exit code is $? running \"${BASH_COMMAND}\""' ERR

echo "Enter"
false
echo "After false 1"

set -e

echo "Before false 2"
false
echo "This will not execute"


More advanced useage of trap and error handling
===============================================
function onBashErrorHandler() {
	case "${BASH_ERROR_LEVEL}" in
		0 | IGNORE | NONE)
			;;
		1 | WARN)
			echo "Warning in ${1}:${2}. Exit code is ${3} running ${4}"
			;;
		2 | EXIT)
			echo "Error in ${1}:${2}. Exit code is ${3} running ${4}"
			exit 1
			;;
	esac
}
BASH_ERROR_LEVEL=IGNORE
set -E	# This is needed to have the same trap in sub-shells and shell function
set -u	# This is to treap unset parameters/variables as errors
trap 'onBashErrorHandler "${BASH_SOURCE}" "${LINENO}" "$?" "${BASH_COMMAND}"' ERR

BASH_ERROR_LEVEL=IGNORE
false # ignored
BASH_ERROR_LEVEL=WARN
false # warning
BASH_ERROR_LEVEL=2
false # error and exit 1
echo "This one will not execute"

Make installation shell script with attached archive at the end
===============================================================
1) install-template.sh
#!/bin/bash
function findToken() {
	grep -an "^${1}\$" "$0" | head -n 1 | cut -d ':' -f 1
}
FILE=$0
OUTPUT_DIR=target_folder
OFFSET=$(($(findToken "___END_OF_SCRIPT___$") + 1))
rm -fr "$OUTPUT_DIR" && mkdir -p "$OUTPUT_DIR" && (tail -n +$OFFSET "$FILE" | tar xz -C "$OUTPUT_DIR" --)
# ... do some other stuff ...

2) Prepare the installation script
#!/bin/bash
FOU=install.sh
cp install-template.sh "$FOU"
echo >> "$FOU"
echo 'exit 0' >> "$FOU"          # This exit is to prevent the bash interpeter go into the binary archive
echo >> "$FOU"
echo '___END_OF_SCRIPT___' >> "$FOU"
tar cz [list_of_file_that_will_be_part_of_archive] >> "$FOU"
chmod +x "$FOU"

Script with configuration section(s) at the end
===============================================
function findToken() {
	grep -anm 1 "^${1}\$" "$0" | cut -d ':' -f 1
}
function extractData() {
	local end=${2:+$(($2-$1-1))}
	tail -n +$(($1+1)) "$0" | head -n ${end:-"-0"} | grep -Ev '^\s*(#.*)?$'
}
DATA_OFFSET_1=$(findToken "___SCRIPT_DATA_SECTION_1___")
DATA_OFFSET_2=$(findToken "___SCRIPT_DATA_SECTION_2___")
DATA1=$(extractData $DATA_OFFSET_1 $DATA_OFFSET_2)
echo "$DATA1"
DATA2=$(extractData $DATA_OFFSET_2)
### Now process the data in section 2
IFS=$'\n'
count=1
for i in $DATA2 ; do 
	IFS=$' \t\n'
	echo Line $count
	count=$(($count+1))
	for j in $i ; do
		echo '>> ' $j
	done
done

exit 0

___SCRIPT_DATA_SECTION_1___
   

asd
	# qwe This is comment line
zxc
	

___SCRIPT_DATA_SECTION_2___
zzz		1	a
aaa		2	b
# aaa # This is comment line
xxx		4  	d


Script with configuration section "in the middle" and variable substitution
===========================================================================
#!/bin/bash
MY_VAR='This will be replaced "inside" the configuration!'
MY_DATA=$(cat << EOF
This is some free text inside a script that can seemlessly handle
variable substituion. Example: The following line
>> \${MY_VAR} <<
is replaced in by bash and becomes:
>> ${MY_VAR} <<
This might be quite usefull.
EOF
)
echo "$MY_DATA"


Bash Redirections Cheat Sheet
=============================
Redirection					Description
cmd > file					Redirect the standard output (stdout) of cmd to a file.
cmd 1> file					Same as cmd > file. 1 is the default file descriptor (fd) for stdout.
cmd 2> file					Redirect the standard error (stderr) of cmd to a file. 2 is the default fd for stderr.
cmd >> file					Append stdout of cmd to a file.
cmd 2>> file				Append stderr of cmd to a file.
cmd &> file					Redirect stdout and stderr of cmd to a file.
cmd > file 2>&1				Another way to redirect both stdout and stderr of cmd to a file. This is not the same as cmd 2>&1 > file. Redirection order matters!
cmd > /dev/null				Discard stdout of cmd.
cmd 2> /dev/null			Discard stderr of cmd.
cmd &> /dev/null			Discard stdout and stderr of cmd.
cmd < file					Redirect the contents of the file to the standard input (stdin) of cmd.
cmd << EOL
line1
line2
EOL							Redirect a bunch of lines to the stdin.  If 'EOL' is quoted, text is treated literally.  This is called a here-document.
cmd <<- EOL
<tab>foo
<tab><tab>bar
EOL							Redirect a bunch of lines to the stdin and strip the leading tabs.
cmd <<< "string"			Redirect a single line of text to the stdin of cmd. This is called a here-string.
exec 2> file				Redirect stderr of all commands to a file forever.
exec 3< file				Open a file for reading using a custom file descriptor.
exec 3> file				Open a file for writing using a custom file descriptor.
exec 3<> file				Open a file for reading and writing using a custom file descriptor.
exec 3>&-					Close a file descriptor.
exec 4>&3					Make file descriptor 4 to be a copy of file descriptor 3. (Copy fd 3 to 4.)
exec 4>&3-					Copy file descriptor 3 to 4 and close file descriptor 3 .
echo "foo" >&3				Write to a custom file descriptor.
cat <&3						Read from a custom file descriptor.
(cmd1; cmd2) > file			Redirect stdout from multiple commands to a file (using a sub-shell).
{ cmd1; cmd2; } > file		Redirect stdout from multiple commands to a file (faster; not using a sub-shell).
exec 3<> /dev/tcp/host/port	Open a TCP connection to host:port. (This is a bash feature, not Linux feature).
exec 3<> /dev/udp/host/port	Open a UDP connection to host:port. (This is a bash feature, not Linux feature).
cmd <(cmd1)					Redirect stdout of cmd1 to an anonymous fifo, then pass the fifo to cmd as an argument. Useful when cmd doesnâ€™t read from stdin directly.
cmd < <(cmd1)				Redirect stdout of cmd1 to an anonymous fifo,  then redirect the fifo to stdin of cmd. Best example: diff <(find /path1 | sort) <(find /path2 | sort).
cmd <(cmd1) <(cmd2)			Redirect  stdout  of cmd1 and cmd2 to  two  anonymous  fifos,  then  pass  both  fifos  as arguments to cmd .
cmd1 >(cmd2)				Run cmd2 with its stdin connected to an anonymous fifo, and pass the filename of the pipe as an argument to cmd1.
cmd1 > >(cmd2)				Run cmd2 with its stdin connected to an anonymous fifo, then redirect stdout of cmd to this anonymous pipe.
cmd1 | cmd2					Redirect stdout of cmd1 to stdin of cmd2.  Pro-tip: This is the same as cmd1 > >(cmd2), same as cmd2 < <(cmd1), same as >(cmd2) cmd1, same as < <(cmd1) cmd2
cmd1 |& cmd2				Redirect  stdout  and  stderr  of cmd1 to  stdin  ofcmd2 (bash  4.0+  only). Use cmd1 2>&1 | cmd2 for older bashes.
cmd | tee file				Redirect stdout of cmdto a file and print it to screen.
exec {filew}> file			Open a file for writing using a named file descriptor called {filew} (bash 4.1+).
cmd 3>&1 1>&2 2>&3			Swap stdout and stderr of cmd.
cmd > >(cmd1) 2> >(cmd2)	Send stdout of cmd to cmd1 and stderr of cmd to cmd2.
cmd1 | cmd2 | cmd3 | cmd4
echo ${PIPESTATUS[@]}		Find out the exit codes of all piped commands.

